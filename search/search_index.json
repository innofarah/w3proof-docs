{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to W3Proof An Exploration of exploiting formal proofs as an additional source of trust on the web \u2192 an exploration of mechanisms for sharing formal proofs in a distributed and trusted manner: an attempt to build a distributed and trusted web of formal proofs . Quoting from W3Proof : While the World Wide Web provides universal methods for publishing documents, the only form of trust provided is that of reputation: that is, one might be willing to trust assertions on a web page that are cryptographically signed by trusted agents. The W3Proof project proposes to develop an additional global and permanent source of trust by exploiting formal proof as well as the principles of transparency and reproducibility. Instead of viewing assertions and their proof evidence as existing in libraries of various proof assistants, we envision a highly distributed network of such assertions that a skeptic can recheck if desired. Concepts from distributed computing and cryptography will be central components to W3Proof. This project is an Exploratory Action proposed and initiated by Dale Miller at Inria Saclay . An Exploratory Action is a term coined by Inria to refer to projects attempting to explore new research themes relative to Inria's usually addressed themes in computer science and which might extend to other areas of knowledge. For more details on the project's idea \u2192 refer to Towards an internet of proof?","title":"Welcome to W3Proof"},{"location":"#welcome-to-w3proof","text":"An Exploration of exploiting formal proofs as an additional source of trust on the web \u2192 an exploration of mechanisms for sharing formal proofs in a distributed and trusted manner: an attempt to build a distributed and trusted web of formal proofs . Quoting from W3Proof : While the World Wide Web provides universal methods for publishing documents, the only form of trust provided is that of reputation: that is, one might be willing to trust assertions on a web page that are cryptographically signed by trusted agents. The W3Proof project proposes to develop an additional global and permanent source of trust by exploiting formal proof as well as the principles of transparency and reproducibility. Instead of viewing assertions and their proof evidence as existing in libraries of various proof assistants, we envision a highly distributed network of such assertions that a skeptic can recheck if desired. Concepts from distributed computing and cryptography will be central components to W3Proof. This project is an Exploratory Action proposed and initiated by Dale Miller at Inria Saclay . An Exploratory Action is a term coined by Inria to refer to projects attempting to explore new research themes relative to Inria's usually addressed themes in computer science and which might extend to other areas of knowledge. For more details on the project's idea \u2192 refer to Towards an internet of proof?","title":"Welcome to W3Proof"},{"location":"introduction/","text":"Introduction & Components Where to Start? Higher-Level Goal At the higher level, this project attempts to address the notion of providing trust , or an additional layer of trust on the web by exploiting formal proofs , in contrast to the usual scene where trust in a statement is provided only through trusting the entity claiming that statement , usually by the public key infrastructure model or by the web of trust model. Trust here could be relevant to many themes , including for example trust in software components , trust in produced scientific results , and trust within journalism and news platforms . Trust on the web within the context of these themes means that the data to be trusted , whatever that might be, is exchanged through the web, and thus the intended source of trust as well needs to be addressed and exchanged within the realm of the web. Naturally, before thinking about how to achieve this wide-range goal itself, the foundations, utilities, or steps needed to achieve it need to be investigated thoroughly. As formal proofs are the driving force and the essence of what the source of trust is desired to be, the sharing and usage of formal proofs within the realm of the web needs to be addressed. Primary Idea Basically, we can consider a formal proof to be an asset that is considered an ultimate guarantee of the validity of some statement (standing on some well-established theory and its implementation). Such an asset is usually produced by theorem provers and proof assistants . The intended idea here is that in addition to providing a formal proof asset as guarantee, the asset could be signed by some entity and provided as an assertion . The reason behind the definition of these two notions of an asset and an assertion is that in the existing theorem proving world, a proof is always rechecked when desired to be reused. This process often requires time and resources; it might be necessary in some cases, but not so in others. However, by allowing the notion of an entity asserting a proof of some theorem, and another entity willing to trust the producing entity, a theorem could be reused without rechecking . You might say here that \" Well, we are still believing a theorem/statement by trusting an entity through the signature and not by the proof itself! \". This is true, at first thought. However, the idea here is that the formal proof is still available for rechecking if desired. For example, two different entities might choose to do two different things - someone might choose to trust a specific entity and thus reuse the statement it provided without further checking, whereas a skeptic might choose to recheck/reproduce the proof \u2192 to recheck the reliability of the received content itself : an additional trust layer . Once we talk about rechecking the reliability of content, it becomes clear that the model to be developed could potentially be applied not only in the area of formal proofs , but also to science in general, as reproducibility is an important concept in the scientific method ~ the fact that we can reproduce some result leads to increased trust in it . However , note that the usage of formal proofs here is beneficial beyond reproducibility , as formal proofs themselves are a significant source of trust. Anyway, this approach of introducing the asset and assertion notions is just the foundational idea to start with, and much is to emerge further. First Step As a result, it makes sense to start the investigation by experimenting with how these assets and assertions can be presented , shared , and distributed through the web, regardless for now, of how different and diverse the forms of assets can be, and what problems will arise from this fact. This diversity is due to the existence of several producers of such assets (theorem provers and proof assistants), which differ in both aspects of their implementation as well as the logical foundations they stand upon, which makes the process of normalizing the form of these assets to exchange them in a distributed and transparent manner non-trivial. But again, this is not the first thing to address, as before worrying about wanting to plant various kinds of trees in a garden, maybe to make it colorful, one first needs to know how to plant a tree in the first place. Hence, we start the W3Proof project by developing a first exploratory tool that is intended to work with one kind of asset producer [and consumer] \u2192 w3proof-dispatch : a first attempt to explore potential possibilities. However, before introducing and illustrating the core idea and functionalities of w3proof-dispatch , let us first present an overview of the main components at the base of this project and the main motivations behind using them. Components Involved Abella: Proof Producer To quote Abella's official website : Abella is an interactive theorem prover based on lambda-tree syntax. This means that Abella is well-suited for reasoning about the meta-theory of programming languages and other logical systems which manipulate objects with binding. Alright, what we really need to say about Abella right now is not something related to the above quotation. Of course it is important, but what we need to deal with currently is what does this tool produce as assets for us to use . Basically, producing a proof for a theorem in Abella consists of introducing in a file for example, some axioms and relevant definitions for the theorem, maybe introducing/proving some other theorems (lemmas) preceding it to be used in its proof, writing the formula of the theorem itself, and then writing the proof steps that will help the proof assistant to complete the proof; the proof steps are usually called proof tactics , and a grouping of them is called a proof script . For you dear reader, this process might look quite familiar, as it is similar to what happens in most other software of this type. If it is not, consider the following example : % Definition of natural numbers % Kind nat type. Type z nat. Type s nat -> nat. Define nat : nat -> prop by nat z; nat (s N) := nat N. % Some theorem : the successor of a natural number, % % according to the above definition of natural numbers, % % is also a natural number. % Theorem succ_nat : forall A, nat A -> nat (s A). % the proof steps: % induction on 1. intros. case H1. search. apply IH to H2. search. >> Proof completed. [after execution] This is an example of what is called a theorem file in Abella , with the .thm extension. The above example as displayed is contained in a single file, however, it could exist differently: in two files nats.thm and some_theorems.thm , one of them Importing the other: % in file \"nats.thm\" % Kind nat type. Type z nat. Type s nat -> nat. Define nat : nat -> prop by nat z; nat (s N) := nat N. % in file \"some_theorems.thm\" % Import \"nats\". Theorem succ_nat : forall A, nat A -> nat (s A). induction on 1. intros. case H1. search. apply IH to H2. search. So, we can say that when we talk about proofs within Abella, what we actually mean is proof scripts which drive the proof assistant to prove a theorem correct, and not proof objects as those existing in the Coq proof assistant , for example. Thus, rechecking in this sense would mean to re-execute the provided proof script within the same software. You can read more about this distinction from this blog post . These proof scripts/theorem files (along with other possible types of files) are what will be currently referred to by the asset notion. More could be said about what could exist in Abella's .thm files, and other types of files. However, the mentioned example should be enough to illustrate the fact that the file dependency concern is quite important , and thus we must take that into consideration when creating the data presentation schema we aspire for . Note that we talk about Abella specifically here as an example of a 'Proof Producer/Consumer' since it is the first proof assistant we are interacting with by the w3proof-dispatch tool , and we should be able to use, in a similar way, other proof producers later. Signatures: Trust Bridge We mentioned two notions earlier in this document: asset and assertion . Basically, assets are produced by a proof producer , which is Abella in the present case, and we will talk about their presentation later in the Data Schema section . To produce an assertion , what we need to utilize is Digital Signatures . So, an assertion would link to a produced asset, its producer's public key, and the corresponding signature. This means that an assertion is only defined when the provided signature is correct, which means that we are ensured that the mentioned entity had actually produced the asset referred to by the provided assertion. We used the word Entity here and not Person for instance because it is more encompassing. Meaning that an Entity does not necessarily only refer to a Person , but it could refer to a Person tied to a specific proof producer for example. The setting could be that a Person might have many identifying public keys/profiles, each referring to a specific proof producer for example, or even a specific version of it, as people might trust a newer version with fixed bugs that existed - as unfixed - in an older version, or trust a specific version for a specific task but not for others, etc. Another setting would be specifically relevant for users of these proof assistants such as mathematicians and software verification engineers during their proof development and publishing process. For example, one user could delay proving some theorem applied in later steps of his proof, and publish the whole proof by keeping this theorem as a guess , i.e., he would sign it by his guessing profile for example, and provide it as a link from his main proof structure. Proving this theorem could be pursued later by another user, and the main proof could be published again, but with a difference : instead of having only one entity to be trusted, trust would be accumulated and trusting the initially guessed theorem would be delegated to the other entity that has proved it, and not to the entity that has guessed it . This idea opens potential for pursuing the notion of distributed proof development and provenance . Signatures are necessary for the notion of trust we intend to introduce in this project. This is because in order to use some statement based on trusting some entity, the basic thing to have is ensuring that the claimed statement was really produced by that entity and not by some malicious actor. Thus, we utilize Digital Signatures that employ asymmetric cryptography , as they proved to be a quite robust way for providing authenticity of shared messages in many use cases. We will be talking in a later section about our use of content-addressing which in fact provides this kind of trust in a link-to-content binding, which might spark the idea of the unnecessity of using signatures to ensure this binding. However, this could be enough at only a first level, i.e., if some entity directly gave us a content-address for an asset , this would be enough to trust its claim of producing the fetched asset (since we are sure that the address will refer to only the initially intended content which if changed, a new address would necessarily refer to it), and we wouldn't need the notion of an assertion . But , as we are aiming for some sort of a structure of assets and assertions produced by different enities, we can not easily abandon using signatures for assertions. IPFS: Content-Addressing After talking briefly about what is meant by each of asset and assertion , which are the components to be shared across the web , we can now talk about a very important building block of W3Proof: IPFS ~ The Interplanetary File System . According to Wikipedia : The InterPlanetary File System ( IPFS ) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system . IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices. Many definitions have been given to IPFS, as what usually happens with any new technology. But we will be brief about the explanation by presenting the main benefits provided by this system and the motivations behind utilizing it in this project . And of course, you can read about IPFS in detail from the official documentation and other resources across the internet. You must be careful however, as with the abundance of definitions, a bunch of them would be wrong or misleading - again, as what usually happens with any new technology, and especially within the Web3 universe . A main goal in W3Proof is to provide a way to share formal proofs in a distributed and trusted manner. [[structuring ipfs ideas - to be continued]] IPLD: Linked Data [[structuring ipld ideas - to be continued]] JSON: Data Schema [[structuring data schema ideas - to be continued]]","title":"Introduction & Components"},{"location":"introduction/#introduction-components","text":"","title":"Introduction &amp; Components"},{"location":"introduction/#where-to-start","text":"","title":"Where to Start?"},{"location":"introduction/#higher-level-goal","text":"At the higher level, this project attempts to address the notion of providing trust , or an additional layer of trust on the web by exploiting formal proofs , in contrast to the usual scene where trust in a statement is provided only through trusting the entity claiming that statement , usually by the public key infrastructure model or by the web of trust model. Trust here could be relevant to many themes , including for example trust in software components , trust in produced scientific results , and trust within journalism and news platforms . Trust on the web within the context of these themes means that the data to be trusted , whatever that might be, is exchanged through the web, and thus the intended source of trust as well needs to be addressed and exchanged within the realm of the web. Naturally, before thinking about how to achieve this wide-range goal itself, the foundations, utilities, or steps needed to achieve it need to be investigated thoroughly. As formal proofs are the driving force and the essence of what the source of trust is desired to be, the sharing and usage of formal proofs within the realm of the web needs to be addressed.","title":"Higher-Level Goal"},{"location":"introduction/#primary-idea","text":"Basically, we can consider a formal proof to be an asset that is considered an ultimate guarantee of the validity of some statement (standing on some well-established theory and its implementation). Such an asset is usually produced by theorem provers and proof assistants . The intended idea here is that in addition to providing a formal proof asset as guarantee, the asset could be signed by some entity and provided as an assertion . The reason behind the definition of these two notions of an asset and an assertion is that in the existing theorem proving world, a proof is always rechecked when desired to be reused. This process often requires time and resources; it might be necessary in some cases, but not so in others. However, by allowing the notion of an entity asserting a proof of some theorem, and another entity willing to trust the producing entity, a theorem could be reused without rechecking . You might say here that \" Well, we are still believing a theorem/statement by trusting an entity through the signature and not by the proof itself! \". This is true, at first thought. However, the idea here is that the formal proof is still available for rechecking if desired. For example, two different entities might choose to do two different things - someone might choose to trust a specific entity and thus reuse the statement it provided without further checking, whereas a skeptic might choose to recheck/reproduce the proof \u2192 to recheck the reliability of the received content itself : an additional trust layer . Once we talk about rechecking the reliability of content, it becomes clear that the model to be developed could potentially be applied not only in the area of formal proofs , but also to science in general, as reproducibility is an important concept in the scientific method ~ the fact that we can reproduce some result leads to increased trust in it . However , note that the usage of formal proofs here is beneficial beyond reproducibility , as formal proofs themselves are a significant source of trust. Anyway, this approach of introducing the asset and assertion notions is just the foundational idea to start with, and much is to emerge further.","title":"Primary Idea"},{"location":"introduction/#first-step","text":"As a result, it makes sense to start the investigation by experimenting with how these assets and assertions can be presented , shared , and distributed through the web, regardless for now, of how different and diverse the forms of assets can be, and what problems will arise from this fact. This diversity is due to the existence of several producers of such assets (theorem provers and proof assistants), which differ in both aspects of their implementation as well as the logical foundations they stand upon, which makes the process of normalizing the form of these assets to exchange them in a distributed and transparent manner non-trivial. But again, this is not the first thing to address, as before worrying about wanting to plant various kinds of trees in a garden, maybe to make it colorful, one first needs to know how to plant a tree in the first place. Hence, we start the W3Proof project by developing a first exploratory tool that is intended to work with one kind of asset producer [and consumer] \u2192 w3proof-dispatch : a first attempt to explore potential possibilities. However, before introducing and illustrating the core idea and functionalities of w3proof-dispatch , let us first present an overview of the main components at the base of this project and the main motivations behind using them.","title":"First Step"},{"location":"introduction/#components-involved","text":"","title":"Components Involved"},{"location":"introduction/#abella-proof-producer","text":"To quote Abella's official website : Abella is an interactive theorem prover based on lambda-tree syntax. This means that Abella is well-suited for reasoning about the meta-theory of programming languages and other logical systems which manipulate objects with binding. Alright, what we really need to say about Abella right now is not something related to the above quotation. Of course it is important, but what we need to deal with currently is what does this tool produce as assets for us to use . Basically, producing a proof for a theorem in Abella consists of introducing in a file for example, some axioms and relevant definitions for the theorem, maybe introducing/proving some other theorems (lemmas) preceding it to be used in its proof, writing the formula of the theorem itself, and then writing the proof steps that will help the proof assistant to complete the proof; the proof steps are usually called proof tactics , and a grouping of them is called a proof script . For you dear reader, this process might look quite familiar, as it is similar to what happens in most other software of this type. If it is not, consider the following example : % Definition of natural numbers % Kind nat type. Type z nat. Type s nat -> nat. Define nat : nat -> prop by nat z; nat (s N) := nat N. % Some theorem : the successor of a natural number, % % according to the above definition of natural numbers, % % is also a natural number. % Theorem succ_nat : forall A, nat A -> nat (s A). % the proof steps: % induction on 1. intros. case H1. search. apply IH to H2. search. >> Proof completed. [after execution] This is an example of what is called a theorem file in Abella , with the .thm extension. The above example as displayed is contained in a single file, however, it could exist differently: in two files nats.thm and some_theorems.thm , one of them Importing the other: % in file \"nats.thm\" % Kind nat type. Type z nat. Type s nat -> nat. Define nat : nat -> prop by nat z; nat (s N) := nat N. % in file \"some_theorems.thm\" % Import \"nats\". Theorem succ_nat : forall A, nat A -> nat (s A). induction on 1. intros. case H1. search. apply IH to H2. search. So, we can say that when we talk about proofs within Abella, what we actually mean is proof scripts which drive the proof assistant to prove a theorem correct, and not proof objects as those existing in the Coq proof assistant , for example. Thus, rechecking in this sense would mean to re-execute the provided proof script within the same software. You can read more about this distinction from this blog post . These proof scripts/theorem files (along with other possible types of files) are what will be currently referred to by the asset notion. More could be said about what could exist in Abella's .thm files, and other types of files. However, the mentioned example should be enough to illustrate the fact that the file dependency concern is quite important , and thus we must take that into consideration when creating the data presentation schema we aspire for . Note that we talk about Abella specifically here as an example of a 'Proof Producer/Consumer' since it is the first proof assistant we are interacting with by the w3proof-dispatch tool , and we should be able to use, in a similar way, other proof producers later.","title":"Abella: Proof Producer"},{"location":"introduction/#signatures-trust-bridge","text":"We mentioned two notions earlier in this document: asset and assertion . Basically, assets are produced by a proof producer , which is Abella in the present case, and we will talk about their presentation later in the Data Schema section . To produce an assertion , what we need to utilize is Digital Signatures . So, an assertion would link to a produced asset, its producer's public key, and the corresponding signature. This means that an assertion is only defined when the provided signature is correct, which means that we are ensured that the mentioned entity had actually produced the asset referred to by the provided assertion. We used the word Entity here and not Person for instance because it is more encompassing. Meaning that an Entity does not necessarily only refer to a Person , but it could refer to a Person tied to a specific proof producer for example. The setting could be that a Person might have many identifying public keys/profiles, each referring to a specific proof producer for example, or even a specific version of it, as people might trust a newer version with fixed bugs that existed - as unfixed - in an older version, or trust a specific version for a specific task but not for others, etc. Another setting would be specifically relevant for users of these proof assistants such as mathematicians and software verification engineers during their proof development and publishing process. For example, one user could delay proving some theorem applied in later steps of his proof, and publish the whole proof by keeping this theorem as a guess , i.e., he would sign it by his guessing profile for example, and provide it as a link from his main proof structure. Proving this theorem could be pursued later by another user, and the main proof could be published again, but with a difference : instead of having only one entity to be trusted, trust would be accumulated and trusting the initially guessed theorem would be delegated to the other entity that has proved it, and not to the entity that has guessed it . This idea opens potential for pursuing the notion of distributed proof development and provenance . Signatures are necessary for the notion of trust we intend to introduce in this project. This is because in order to use some statement based on trusting some entity, the basic thing to have is ensuring that the claimed statement was really produced by that entity and not by some malicious actor. Thus, we utilize Digital Signatures that employ asymmetric cryptography , as they proved to be a quite robust way for providing authenticity of shared messages in many use cases. We will be talking in a later section about our use of content-addressing which in fact provides this kind of trust in a link-to-content binding, which might spark the idea of the unnecessity of using signatures to ensure this binding. However, this could be enough at only a first level, i.e., if some entity directly gave us a content-address for an asset , this would be enough to trust its claim of producing the fetched asset (since we are sure that the address will refer to only the initially intended content which if changed, a new address would necessarily refer to it), and we wouldn't need the notion of an assertion . But , as we are aiming for some sort of a structure of assets and assertions produced by different enities, we can not easily abandon using signatures for assertions.","title":"Signatures: Trust Bridge"},{"location":"introduction/#ipfs-content-addressing","text":"After talking briefly about what is meant by each of asset and assertion , which are the components to be shared across the web , we can now talk about a very important building block of W3Proof: IPFS ~ The Interplanetary File System . According to Wikipedia : The InterPlanetary File System ( IPFS ) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system . IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices. Many definitions have been given to IPFS, as what usually happens with any new technology. But we will be brief about the explanation by presenting the main benefits provided by this system and the motivations behind utilizing it in this project . And of course, you can read about IPFS in detail from the official documentation and other resources across the internet. You must be careful however, as with the abundance of definitions, a bunch of them would be wrong or misleading - again, as what usually happens with any new technology, and especially within the Web3 universe . A main goal in W3Proof is to provide a way to share formal proofs in a distributed and trusted manner. [[structuring ipfs ideas - to be continued]]","title":"IPFS: Content-Addressing"},{"location":"introduction/#ipld-linked-data","text":"[[structuring ipld ideas - to be continued]]","title":"IPLD: Linked Data"},{"location":"introduction/#json-data-schema","text":"[[structuring data schema ideas - to be continued]]","title":"JSON: Data Schema"},{"location":"w3proof-dispatch/","text":"w3proof-dispatch Repository on Github","title":"w3proof-dispatch"},{"location":"w3proof-dispatch/#w3proof-dispatch","text":"Repository on Github","title":"w3proof-dispatch"}]}